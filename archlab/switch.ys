.pos 0
	irmovq stack, %rsp
	call main
	halt
	
.align 8
array:
	.quad 0x0000
	.quad 0x0000
	.quad 0x0000
	.quad 0x0000
	.quad 0x0000
	.quad 0x0000
	.quad 0x0000
	.quad 0x0000
main:
	irmovq array, %r12
	
	irmovq $0, %rdi
	call switchv
	rmmovq %rax, (%r12)
	
	irmovq $1, %rdi
	call switchv
	rmmovq %rax, 8(%r12)
	
	irmovq $2, %rdi
	call switchv
	rmmovq %rax, 16(%r12)
	
	irmovq $3, %rdi
	call switchv
	rmmovq %rax, 24(%r12)
	
	irmovq $4, %rdi
	call switchv
	rmmovq %rax, 32(%r12)
	
	irmovq $5, %rdi
	call switchv
	rmmovq %rax, 40(%r12)
	
	irmovq $6, %rdi
	call switchv
	rmmovq %rax, 48(%r12)
	
	irmovq $7, %rdi
	call switchv
	rmmovq %rax, 56(%r12)
	
	ret
	
table:
	.quad L0
	.quad LD
	.quad L5
	.quad L3
	.quad LD
	.quad L5
	.quad LD
	.quad LD
	.quad LD
	.quad LD
	
switchv:
	irmovq $8, %r8
	irmovq $0, %r10
	irmovq $1, %r11
	
	irmovq table, %rcx
	
	# if idx > 0
	rrmovq %rdi, %rbx
	subq %r8, %rbx
	jge def
	# if idx < 0
	subq %r10, %rdi
	jl def 
	
mul:
	subq %r10, %rdi
	je switch
	addq %r8, %rcx
	subq %r11, %rdi
	jmp mul
	
def:
	rrmovq %r8, %rdi
	jmp mul
	
switch:
	mrmovq (%rcx), %rbx
	pushq %rbx
	ret
	
L0:
	irmovq 0xaaa, %rax
	ret

L3:
	irmovq 0xccc, %rax
	ret

L5:
	irmovq 0xbbb, %rax
	ret
LD:
	irmovq 0xddd, %rax
	ret


.pos 0x400
stack:
	
